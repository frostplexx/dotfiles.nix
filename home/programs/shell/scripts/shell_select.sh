#!/usr/bin/env bash

# Configuration
DOTFILES_DIR="$HOME/dotfiles.nix"
SHELLS_DIR="$DOTFILES_DIR/templates"
DIRENV_FILE=".envrc"
CACHE_DIR="$HOME/.local/share/shinit"
SHELL_CACHE_FILE="$CACHE_DIR/shells/$(pwd | md5sum | cut -d' ' -f1)"
EVAL_CACHE_DIR="$CACHE_DIR/eval-cache"
NIX_CACHE_DIR="$CACHE_DIR/nix-cache"

# Create cache directories
mkdir -p "$CACHE_DIR/shells" "$EVAL_CACHE_DIR" "$NIX_CACHE_DIR"

# Function to generate cache key for current directory
get_cache_key() {
    local dir_hash
    dir_hash=$(pwd | md5sum | cut -d' ' -f1)
    printf "%s/%s" "$EVAL_CACHE_DIR" "$dir_hash"
}

# Function to generate .envrc file with caching
generate_envrc() {
    local shell_name="$1"
    local cache_file
    cache_file=$(get_cache_key)

    # Create a GC root for the shell
    local gc_root="$NIX_CACHE_DIR/$shell_name"
    if [ ! -L "$gc_root" ] || [ ! -e "$gc_root" ]; then
        nix build "$DOTFILES_DIR#$shell_name" --out-link "$gc_root" &>/dev/null
    fi

    # Check if cached environment exists and is recent (less than 1 day old)
    if [ -f "$cache_file" ] && [ -n "$(find "$cache_file" -mtime -1 2>/dev/null)" ]; then
        cp "$cache_file" "$DIRENV_FILE"
    else
        {
            echo "# Generated by shinit on $(date -Iseconds)"
            echo "watch_file $SHELLS_DIR/$shell_name.nix"
            echo "if ! has nix_direnv_version || ! nix_direnv_version 2.3.0; then"
            echo "    source_url \"https://raw.githubusercontent.com/nix-community/nix-direnv/2.3.0/direnvrc\" \"sha256-Dmd+j63L/PvgAhs4I5E/Vp5YfYwc3R9CF6+PHWfj5g4=\""
            echo "fi"
            echo "use flake \"$DOTFILES_DIR#$shell_name\""
            echo "export DIRENV_LOG_FORMAT=\"\""
            # Add eval caching
            echo "eval \"\$(command nix print-dev-env --profile $gc_root)\""
        } | tee "$DIRENV_FILE" > "$cache_file"
    fi

    echo "$shell_name" > "$SHELL_CACHE_FILE"
}

# Function to get last used shell for this directory
get_last_shell() {
    [ -f "$SHELL_CACHE_FILE" ] && cat "$SHELL_CACHE_FILE"
}

# Function to list available shells (cached)
get_available_shells() {
    local shells_cache="$CACHE_DIR/available-shells.list"
    local shells_timestamp="$CACHE_DIR/available-shells.timestamp"
    local current_time
    current_time=$(date +%s)

    if [ -f "$shells_cache" ] && [ -f "$shells_timestamp" ]; then
        local cache_time
        cache_time=$(cat "$shells_timestamp")
        if [ $((current_time - cache_time)) -lt 3600 ]; then
            cat "$shells_cache"
            return
        fi
    fi

    {
        ls -1 "$SHELLS_DIR" | 
        grep '\.nix$' | 
        sed 's/\.nix$//' | 
        grep -v '^default$'
    } > "$shells_cache"

    echo "$current_time" > "$shells_timestamp"
    cat "$shells_cache"
}

# Cleanup old cache files (runs in background)
{
    find "$EVAL_CACHE_DIR" -type f -mtime +7 -delete
    find "$CACHE_DIR/shells" -type f -mtime +7 -delete
    
    # Cleanup broken GC roots
    for root in "$NIX_CACHE_DIR"/*; do
        if [ -L "$root" ] && [ ! -e "$root" ]; then
            rm "$root"
        fi
    done
} 2>/dev/null &

# Main logic
if [ -f "$DIRENV_FILE" ]; then
    last_shell=$(get_last_shell)
    if [ -n "$last_shell" ]; then
        selected_shell="$last_shell"
    fi
else
    selected_shell=$(get_available_shells | fzf \
        --prompt="Select shell: " \
        --preview="bat --color=always --style=plain $SHELLS_DIR/{}.nix 2>/dev/null || cat $SHELLS_DIR/{}.nix" \
        --preview-window=right:50%:wrap)
fi

if [ -n "$selected_shell" ]; then
    # Generate .envrc file with caching
    generate_envrc "$selected_shell"
    
    # Allow direnv with completely silent output
    {
        DIRENV_LOG_FORMAT="" direnv allow
        direnv reload
    } &>/dev/null
    
    printf '\033[32mâœ“\033[0m Shell \033[1m%s\033[0m activated\n' "$selected_shell"
fi
