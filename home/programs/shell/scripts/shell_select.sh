#!/usr/bin/env bash

# Configuration
DOTFILES_DIR="$HOME/dotfiles.nix"
SHELLS_DIR="$DOTFILES_DIR/templates"
DIRENV_FILE=".envrc"
CACHE_DIR="$HOME/.local/share/shinit"
SHELL_CACHE_FILE="$CACHE_DIR/shells/$(pwd | md5sum | cut -d' ' -f1)"
EVAL_CACHE_DIR="$CACHE_DIR/eval-cache"
NIX_CACHE_DIR="$CACHE_DIR/nix-cache"

# Create cache directories
mkdir -p "$CACHE_DIR/shells" "$EVAL_CACHE_DIR" "$NIX_CACHE_DIR"

# Function to generate cache key for current directory
get_cache_key() {
    local dir_hash
    dir_hash=$(pwd | md5sum | cut -d' ' -f1)
    printf "%s/%s" "$EVAL_CACHE_DIR" "$dir_hash"
}

# Function to create a custom flake template
create_custom_flake() {
    local flake_file="flake.nix"
    local current_dir="$(pwd)"
    
    # Create flake.nix in the current directory
    cat > "$current_dir/$flake_file" << 'EOF'
{
  description = "Custom development environment";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            # Add your packages here
          ];

          shellHook = ''
            echo "Welcome to your custom development environment!"
          '';
        };
      }
    );
}
EOF
    
    echo "Created custom flake template in: $current_dir/$flake_file"
}

# Function to generate .envrc file with caching
generate_envrc() {
    local shell_name="$1"
    local cache_file
    cache_file=$(get_cache_key)

    # For custom flakes, we create a simpler .envrc that just uses direnv
    if [ "$shell_name" = "custom" ]; then
        {
            echo "# Generated by shinit on $(date -Iseconds)"
            echo "use flake"
        } > "$DIRENV_FILE"
        return
    fi

    # Create a GC root for the shell
    local gc_root="$NIX_CACHE_DIR/$shell_name"
    if [ ! -L "$gc_root" ] || [ ! -e "$gc_root" ]; then
        nix build "$DOTFILES_DIR#$shell_name" --out-link "$gc_root" &>/dev/null
    fi

    # Check if cached environment exists and is recent (less than 1 day old)
    if [ -f "$cache_file" ] && [ -n "$(find "$cache_file" -mtime -1 2>/dev/null)" ]; then
        cp "$cache_file" "$DIRENV_FILE"
    else
        {
            echo "# Generated by shinit on $(date -Iseconds)"
            # Silence direnv output completely
            echo "export DIRENV_LOG_FORMAT=\"\""
            echo "export DIRENV_WARN_TIMEOUT=\"0s\""
            # Prevent nix-direnv from showing its own status messages
            echo "export NIX_GET_COMPLETIONS=0"
            echo "export DIRENV_LOG_FORMAT=\"\""
            # Source nix-direnv with silent output
            echo "if ! has nix_direnv_version || ! nix_direnv_version 2.3.0; then"
            echo "    source_url \"https://raw.githubusercontent.com/nix-community/nix-direnv/2.3.0/direnvrc\" \"sha256-Dmd+j63L/PvgAhs4I5E/Vp5YfYwc3R9CF6+PHWfj5g4=\" &>/dev/null"
            echo "fi"
            # Load the flake silently
            echo "{ watch_file $SHELLS_DIR/$shell_name.nix; } &>/dev/null"
            echo "use flake \"$DOTFILES_DIR#$shell_name\" --quiet &>/dev/null"
            # Evaluate the environment silently
            echo "{ eval \"\$(command nix print-dev-env --profile $gc_root)\"; } &>/dev/null"
            # Add a hook to suppress the export list
            echo "direnv_load(){ eval \"\$(\"$direnv\" export bash)\" 1>&2; }"
        } | tee "$DIRENV_FILE" > "$cache_file"
    fi

    echo "$shell_name" > "$SHELL_CACHE_FILE"
}

# Function to get last used shell for this directory
get_last_shell() {
    [ -f "$SHELL_CACHE_FILE" ] && cat "$SHELL_CACHE_FILE"
}

# Function to list available shells (cached)
get_available_shells() {
    local shells_cache="$CACHE_DIR/available-shells.list"
    local shells_timestamp="$CACHE_DIR/available-shells.timestamp"
    local current_time
    current_time=$(date +%s)

    if [ -f "$shells_cache" ] && [ -f "$shells_timestamp" ]; then
        local cache_time
        cache_time=$(cat "$shells_timestamp")
        if [ $((current_time - cache_time)) -lt 3600 ]; then
            cat "$shells_cache"
            return
        fi
    fi

    {
        ls -1 "$SHELLS_DIR" | 
        grep '\.nix$' | 
        sed 's/\.nix$//' | 
        grep -v '^default$'
    } > "$shells_cache"

    echo "$current_time" > "$shells_timestamp"
    cat "$shells_cache"
}

# Cleanup old cache files (runs in background)
{
    find "$EVAL_CACHE_DIR" -type f -mtime +7 -delete
    find "$CACHE_DIR/shells" -type f -mtime +7 -delete
    
    # Cleanup broken GC roots
    for root in "$NIX_CACHE_DIR"/*; do
        if [ -L "$root" ] && [ ! -e "$root" ]; then
            rm "$root"
        fi
    done
} 2>/dev/null &

# Main logic
if [ -f "$DIRENV_FILE" ]; then
    last_shell=$(get_last_shell)
    if [ -n "$last_shell" ]; then
        selected_shell="$last_shell"
    fi
else
    # Get list of shells and add custom option
    selected_shell=$((echo "custom"; get_available_shells) | fzf \
        --prompt="Select shell: " \
        --preview="if [ {} = 'custom' ]; then echo -e '\033[1mCreate a new custom development environment\033[0m\n\nThis will create a new flake.nix in the current directory with a basic development shell template that you can customize.'; else bat --color=always --style=plain $SHELLS_DIR/{}.nix 2>/dev/null || cat $SHELLS_DIR/{}.nix; fi" \
        --preview-window=right:50%:wrap)
fi

if [ -n "$selected_shell" ]; then
    if [ "$selected_shell" = "custom" ]; then
        if [ -f "flake.nix" ]; then
            echo "Error: flake.nix already exists in the current directory"
            exit 1
        fi
        
        create_custom_flake
        selected_shell="custom"
    fi
    
    # Generate .envrc file with caching
    generate_envrc "$selected_shell"
    
    # Allow direnv with completely silent output
    {
        export DIRENV_LOG_FORMAT=""
        direnv allow
        direnv reload
    } &>/dev/null
    
    printf '\033[32mâœ“\033[0m Shell \033[1m%s\033[0m activated\n' "$selected_shell"
fi
